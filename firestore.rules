/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict role-based and ownership-based security model for the Creative Talent Agency Web App.
 *
 * Core Philosophy:
 *  - Enforce a role-based access control, with talent able to manage their own profiles and admins managing everything else.
 *  - Prioritize security and data protection.
 *  - Optimize for performance and scalability using Authorization Independence through data denormalization.
 *
 * Data Structure:
 *  - /talents/{talentId}: Stores talent profiles.
 *  - /talents/{talentId}/portfolioItems/{portfolioItemId}: Stores portfolio items associated with talent profiles.
 *  - /blogPosts/{blogPostId}: Stores blog posts.
 *  - /messages/{messageId}: Stores messages submitted via the contact form.
 *  - /roles_admin/{uid}: Stores admin roles.
 *
 * Key Security Decisions:
 *  - Talent can only manage their own profiles and associated portfolio items.
 *  - Admins have full access to all data.
 *  - Data validation is limited to authorization-critical fields.
 *  - Authorization Independence is maintained by denormalizing `talentId` into portfolio items.
 *  - The existence of a document in `/roles_admin/{uid}` indicates the user is an admin.
 *
 * Denormalization for Authorization:
 *  - Each `portfolioItem` has a `talentId` field that matches the parent talent's ID. This enables rules to authorize access to portfolio items based on talent ownership without additional `get()` calls.
 *
 * Structural Segregation:
 *  - Admin roles are stored in a separate collection (`/roles_admin`) instead of within the user document. This simplifies the rules and allows for easier role management.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows talent to manage their own profiles and admins to manage all talent profiles.
     * @path /talents/{talentId}
     * @allow (create) Talent with matching talentId can create their profile. Auth: {uid: "talent123"}, Data: {id: "talent123"}
     * @allow (get,list) Anyone can read an approved talent profile.
     * @allow (update,delete) Talent with matching talentId can update/delete their profile, and admins can update/delete any profile. Auth: {uid: "talent123"}, ResourceData: {id: "talent123"}
     * @deny (create) Talent tries to create a profile with a mismatched talentId. Auth: {uid: "talent123"}, Data: {id: "talent456"}
     * @deny (update,delete) Talent tries to update/delete another talent's profile. Auth: {uid: "talent123"}, ResourceData: {id: "talent456"}
     * @principle Enforces document ownership for writes and allows public read access.
     */
    match /talents/{talentId} {
      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && isOwner(talentId) && request.resource.data.id == talentId;
      allow update, delete: if isSignedIn() && (isOwner(talentId) && isExistingOwner(talentId) || isAdmin());
    }

    /**
     * @description Allows talent to manage their own portfolio items and admins to manage all portfolio items.
     * @path /talents/{talentId}/portfolioItems/{portfolioItemId}
     * @allow (create) Talent with matching talentId can create a portfolio item. Auth: {uid: "talent123"}, Data: {talentId: "talent123"}
     * @allow (get,list) Any signed-in user can read/list portfolio items. Auth: {uid: "user456"}
     * @allow (update,delete) Talent with matching talentId can update/delete their own portfolio items, and admins can update/delete any portfolio item. Auth: {uid: "talent123"}, ResourceData: {talentId: "talent123"}
     * @deny (create) Talent tries to create a portfolio item with a mismatched talentId. Auth: {uid: "talent123"}, Data: {talentId: "talent456"}
     * @deny (update,delete) Talent tries to update/delete another talent's portfolio item. Auth: {uid: "talent123"}, ResourceData: {talentId: "talent456"}
     * @principle Enforces document ownership for writes and allows public read access.  Maintains Authorization Independence through data denormalization.
     */
    match /talents/{talentId}/portfolioItems/{portfolioItemId} {
      allow get: if true;
      allow list: if true;

      allow create: if isSignedIn() && isOwner(talentId) && request.resource.data.talentId == talentId;
      allow update, delete: if isSignedIn() && (isOwner(talentId) && isExistingOwner(talentId) && resource.data.talentId == talentId || isAdmin());
    }

    /**
     * @description Allows only admins to manage blog posts.
     * @path /blogPosts/{blogPostId}
     * @allow (create,update,delete) Admins can create, update, and delete blog posts. Auth: {uid: "admin123"}
     * @allow (get,list) Any signed-in user can read/list blog posts. Auth: {uid: "user456"}
     * @deny (create,update,delete) Non-admins try to create, update, or delete blog posts. Auth: {uid: "user456"}
     * @principle Enforces role-based access control.
     */
    match /blogPosts/{blogPostId} {
      allow get: if true;
      allow list: if true;

      allow create, update, delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Manages access to the messages collection.
     * @path /messages
     */
    match /messages/{messageId} {

        /**
         * @description Allows any signed-in user to create a message, and allows admins to list all messages.
         * This is necessary for the public contact form and the admin message dashboard.
         */
        allow list: if isSignedIn() && isAdmin();
        allow create: if true;

        /**
         * @description Allows only admins to read, update, or delete individual messages.
         * Non-admins cannot access specific messages.
         */
        allow get, update, delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Allows only admins to have a document created in the role collection
     * @path /roles_admin/{uid}
     * @allow (create) Any signed-in user can create an admin role entry for themselves.  This would normally be done via a trusted backend.
     * @allow (get) Anyone can check for admin role.
     * @allow (delete) Admins can delete a role document. Auth: {uid: "admin123"}
     * @deny (update) No one can update an admin role entry.
     * @deny (delete) Non-admin tries to delete an admin role entry. Auth: {uid: "user456"}
     */
    match /roles_admin/{uid} {
      allow get: if isSignedIn() && request.auth.uid == uid;
      allow list: if false; // Nobody can list the roles_admin collection

      allow create: if isSignedIn() && request.auth.uid == uid;
      allow update: if false;
      allow delete: if isSignedIn() && isAdmin();
    }

    // ---- Helper functions ----

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the document.
     * @param {string} userId - The user ID to check against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the document and the document exists.
     * @param {string} userId - The user ID to check against.
     * @return {boolean} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user is an admin by checking for a document in the roles_admin collection.
     * @return {boolean} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
  }
}
